### Reverse a string

- Time Complexity: O(n)
- Efficient Solution: Two-pointer approach or in-place reversal.

### Check if a string is a palindrome

- Time Complexity: O(n)
- Efficient Solution: Two-pointer approach.

### Find the first non-repeating character in a string

- Time Complexity: O(n)
- Efficient Solution: Hash map to count occurrences.

### Implement strstr() (find the first occurrence of a substring)

- Time Complexity: O(n \* m) for naive; O(n + m) for KMP algorithm.
- Efficient Solution: Knuth-Morris-Pratt (KMP) algorithm.

### Longest Substring Without Repeating Characters

- Time Complexity: O(n)
- Efficient Solution: Sliding window with hash set.

### Longest Palindromic Substring

- Time Complexity: O(n^2) for dynamic programming; O(n) for Manacherâ€™s algorithm.
- Efficient Solution: Manacher's algorithm.

### String to Integer (atoi)

- Time Complexity: O(n)
- Efficient Solution: Linear scan with careful parsing.

### Longest Common Prefix

- Time Complexity: O(n \* m)
- Efficient Solution: Horizontal scanning or binary search.

### Count and Say

- Time Complexity: O(n \* m)
- Efficient Solution: Simulation with string building.

### Valid Parentheses

- Time Complexity: O(n)
- Efficient Solution: Stack.

### Group Anagrams

- Time Complexity: O(n \* k log k)
- Efficient Solution: Hash map with sorted strings as keys.

### Minimum Window Substring

- Time Complexity: O(n)
- Efficient Solution: Sliding window with hash map.

### Roman to Integer

- Time Complexity: O(n)
- Efficient Solution: Linear scan with value mapping.

### Implement an algorithm to determine if a string has all unique characters

- Time Complexity: O(n)
- Efficient Solution: Hash set or bit vector.

### Longest Repeating Character Replacement

- Time Complexity: O(n)
- Efficient Solution: Sliding window.

### Find All Anagrams in a String

- Time Complexity: O(n)
- Efficient Solution: Sliding window with frequency array.

### Repeated DNA Sequences

- Time Complexity: O(n)
- Efficient Solution: Hash set with sliding window.

### Encode and Decode Strings

- Time Complexity: O(n)
- Efficient Solution: Custom encoding with delimiter.

### Reverse Words in a String

- Time Complexity: O(n)
- Efficient Solution: Reverse entire string and then reverse each word.

### Longest Palindromic Subsequence

- Time Complexity: O(n^2)
- Efficient Solution: Dynamic programming.

### Wildcard Matching

- Time Complexity: O(n \* m)
- Efficient Solution: Dynamic programming.

### Regular Expression Matching

- Time Complexity: O(n \* m)
- Efficient Solution: Dynamic programming.

### Edit Distance

- Time Complexity: O(n \* m)
- Efficient Solution: Dynamic programming.

### Scramble String

- Time Complexity: O(n^4)
- Efficient Solution: Dynamic programming with memoization.

### Isomorphic Strings

- Time Complexity: O(n)
- Efficient Solution: Hash map for character mapping.

### Word Break

- Time Complexity: O(n^2)
- Efficient Solution: Dynamic programming with hash set.

### Word Search

- Time Complexity: O(n _ m _ 4^L) where L is the length of the word.
- Efficient Solution: Backtracking.

### Longest Substring with At Most K Distinct Characters

- Time Complexity: O(n)
- Efficient Solution: Sliding window with hash map.

### Generate Parentheses

- Time Complexity: O(4^n / sqrt(n))
- Efficient Solution: Backtracking.

### Simplify Path

- Time Complexity: O(n)
- Efficient Solution: Stack.

### Compare Version Numbers

- Time Complexity: O(n)
- Efficient Solution: Split and compare segments.

### Remove Invalid Parentheses

- Time Complexity: O(2^n)
- Efficient Solution: BFS for minimal removals.

### Basic Calculator

- Time Complexity: O(n)
- Efficient Solution: Stack for operators and operands.

### Text Justification

- Time Complexity: O(n)
- Efficient Solution: Greedy approach.

### Longest Substring with At Least K Repeating Characters

- Time Complexity: O(n)
- Efficient Solution: Divide and conquer.

### Find the Difference

- Time Complexity: O(n)
- Efficient Solution: XOR or hash map.

### Ransom Note

- Time Complexity: O(n)
- Efficient Solution: Array or hash map for character count.

### Sort Characters By Frequency

- Time Complexity: O(n log n)
- Efficient Solution: Hash map with bucket sort.

### One Edit Distance

- Time Complexity: O(n)
- Efficient Solution: Linear scan with conditions.

### Longest Word in Dictionary through Deleting

- Time Complexity: O(n \* k)
- Efficient Solution: Two-pointer technique.

### Valid Palindrome II

- Time Complexity: O(n)
- Efficient Solution: Two-pointer approach with one skip.

### Decode String

- Time Complexity: O(n)
- Efficient Solution: Stack for nested decoding.

### Integer to English Words

- Time Complexity: O(n)
- Efficient Solution: Division and recursion.

### Basic Calculator II

- Time Complexity: O(n)
- Efficient Solution: Stack for operators and operands.

### Longest Substring with At Most Two Distinct Characters

- Time Complexity: O(n)
- Efficient Solution: Sliding window with hash map.

### Palindrome Pairs

- Time Complexity: O(n \* k^2)
- Efficient Solution: Trie with hash map.

### Rotate String

- Time Complexity: O(n)
- Efficient Solution: Concatenation and substring check.

### Number of Matching Subsequences

- Time Complexity: O(n + m)
- Efficient Solution: Buckets for each character and binary search.

### Longest Uncommon Subsequence II

- Time Complexity: O(n^2 \* k)
- Efficient Solution: Brute force with all substrings.

### Reorganize String

- Time Complexity: O(n log n)
- Efficient Solution: Heap or greedy approach.

### Check If Two String Arrays are Equivalent

- Time Complexity: O(n)
- Efficient Solution: Concatenate and compare.

### Remove All Adjacent Duplicates In String

- Time Complexity: O(n)
- Efficient Solution: Stack.

### Check If a String Contains All Binary Codes of Size K

- Time Complexity: O(n)
- Efficient Solution: Sliding window with hash set.

### Design Add and Search Words Data Structure

- Time Complexity: O(n)
- Efficient Solution: Trie.
